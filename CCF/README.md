# CCF
the CCF test
***
## 2013 - 12
* 1.出现次数最多的数
    * MaxOccurNums.cpp
    * 两种思路，一是由于给定的数据范围不超过1000，所以直接用固定空间的数组方法。然后统计出现次数最多的数字即可，而且从前向后遍历保证了先输出的是最小的。另外可以做一些小的优化，就是在读入数据的时候记录下读到这个数据的时候出现最多的次数，然后再去遍历找这个次数的数即可。另外一种思路就是使用map容器，其他方法一样
* 2.ISBN号码
    * IsRightISBN.cpp
    * 这种就是考基本操作的题目，注意边界条件就好了
* 3.最大的矩形
    * MaxMatric.cpp
    * 比较笨的方法就是直接遍历，对每一条柱都进行左右搜素，最后输出最大值就好了。较好的方法是使用一个栈来维护一个矩形高度递增有序的序列，然后读入一个比栈顶高度低的值时，退栈计算以此高度能得到的最大面积，然后将该面积入栈，最后将栈中元素依次弹出计算面积，取最大值。
* 4.有趣的数
    * InterestingNumber.cpp
    * 动态规划，明白了别人的思路很容易，自己想不出来啊
* 5.I'm Stuck
    * Imstuck.cpp
    * 求有没有通路，DFS即可，从开始点S和终结点T分别做做DFS，标记可访问的点，需要两个和地图大小一样的二维数组（bool型）即可，难处在DFS边界点的判断，已经地图点可移动方向的判断，使用0000四位二进制数来标识可移动并将其与位操作结合是个相当巧妙的办法。（仰望大佬）
***
## 2014 - 03
* 1.相反数
    * OppositeNum.cpp
    * 直接两重循环遍历查找，用标志记录一下已经确认过的就好了。
* 2.窗口
    * WindowClick.cpp
    * 用数组把窗口范围储存来，对点击命令搜索在不在窗口范围内，被点中的窗口要移动到数组的最后面。一开始打算用栈来实现，发现移动也是很麻烦。vector有erase(),可以直接删除这个元素再再队尾插入。（不过估计实现的原理还是元素移动）
* 3.命令行选项
    * CmdAnalysis_AC.cpp
    * AC的代码时网上找的，自己写一开始就只有30，照着改了改也只有50分，思路是一样，主要是字符串处理细节太多。多输出个空格都会error。
* 4.无线网络
    * WirelessNetwork_AC.cpp
    * 给出输入数据坐标范围很大，不可能通过邻接矩阵存储，所以使用邻接表法，由于只需要判断两个结点直接是否连通，则邻接表中只需要存储结点值标号即可，即对某一个结点的邻接表是一个数组。另外，题目具有迷惑性，直接把旧的和新的要加入的一块存入邻接表，然后使用BFS即可，进行BFS所用的队列中维护跳数信息，然后到达终点是返回这个值就好了。
* _5.任务调度_
    * TaskDispatch_10_TimeLimits.cpp
    * 使用回溯法。超时，不会做（也没有找到别人的做法）
***
## 2014 - 09
* 1.相邻数对
    * Diff1Pairs.cpp 
    * 排序后遍历查找前后相差为1的即可，是否是稳定排序不影响，冒泡和快排都可以。
* 2.画图
    * Painting.cpp
    * 直接使用二维数组标记，对所有输入范围的元素值标记为真，遍历计数即可（注意下题目给的坐标）
* 3.字符串匹配
    * StrMatch.cpp
    * 直接使用查找即可，忽略大小写差异可通过将要比较的串都变成小写再查找。
* 4.最优配餐
    * MealDeliver.cpp
    * 二维的网格图，使用类似与Imstuck的思路，不过这里要选择最短的路径，所以使用BFS，边界判断思路是一致的。同时从商店结点开始BFS,对某一客户一定是离得近的商店先访问到，保证了求出的路径是最小的路径。
* _5.拼图_
    * Puzzle.cpp_0_
    * __不会做__，只输出一组测试用例的正确结果是不会得分的。。。
***
## 2014 - 12
* 1.门禁系统
    * ReaderNo.cpp
    * 两个数组，一个用于记录输入，一个用于计数即可，也可以使用map容器
* 2.Z字形扫描
    * ZigzagScan.cpp
    * 主要是边界的判断，大概思路是每次斜向扫描是i+j的值是固定的，每变一下向i+j的值加一。所以使用a[i][num-i]并注意判断边界即可，每一轮扫描后num++。
* _3.集合竞价_
* _4.最优灌溉_
* _5.货物调度_
***
## 2015 - 03
* 1.图像旋转
    * ImageRotation.cpp
    * 按列优先倒过来（从最大列，最小行开始）一列一列输出就行了。
* 2.数字排序
    * NumFrequentCount.cpp
    * 用第二维度为2的数组存储，也可用两个大小一样的数组，[][0]存放编号，[][1]存放频数，以为关键字频数稳定排序即可（因为有一样的要先输出小的编号，注意冒泡和选排序的区别）
* 3.节日
    * HolidayDate.cpp
    * 计算题，总结一下规律即可，先获取要求的这一年的第一天的星期，这求要求月份的的一天是星期几，然后求这个月的第几个周几是这个月的第多少天，超过了这个月的天数不存在。
* _4.网路延时_
* _5.最小花费_
***
## 2015 - 09
* 1.数列分段
    * GroupNums.cpp
    * 遍历，cur记录当前值，遇到不一样的更新，段数加1。
* 2.日期计算
    * DateCount.cpp
    * 这比201503的第三题简单多了
* _3.模板生成系统_
    * Templates_90_runerror.cpp
    * 字符串处理，运行只有90分，最后运行出错，不知道错哪儿了。
* _4.高速公路_
* _5.最佳文章_
***
## 2015 - 12
* 1.数位之和
    * SumofDigits.cpp
    * 不断对10取余数相加就好了。
* 2.消除类游戏
    * DissolveNums.cpp
    * 使用一个同样大小的标志数组，按行和按列分别扫描，将要消除的位置标记，然后再一个二重循环，将标记的位置置0。
* 3.画图
    * AsciiArt_90_error.cpp
    * 字符串真实死穴啊啊啊啊啊，明明自己测试都对，然后提交了就出错。
* _4.送货_
* _5.矩阵_
    * Matrix_10_TimeLimit.cpp
    * 这个计算很简单，只是直接循环计算只有10分，需要使用矩阵快速幂进行优化，A^2 A^4 A^8 ...等。
***
## 2016 - 04
* 1.折点计数
    * ExtremePoint.cpp
    * 从1 -> n-1 找比两边都大的数就ok。
* 2.俄罗斯方块
    * Tetris_bits.cpp
    * 先输入存到数组中，转换为相应的二进制位值，然后使用位操作判断能否下移一步，能下移，直到不能移动就停止，将位串转换为数组扫描输出。中间遇到一个bug，在底部为空时，因为没有位操作没有限界，移位会出界。本来应该落到最下面一行的图形，出界之后就没有了。另外原题描述中关于左边界描述，坑啊妈的，多说一句含糊不清的话干嘛。
    * Tetris_array.cpp
    * 这个是网上找的AC的代码，思路更加简洁。要确定最终停在的位置，则只需要确定四列中哪一行起决定作用就好。决定性的列的图中最上面的 1 的行号和图形中最下面的 1 的行号差值最小。然后对应位置拷贝数组就好了。
* 3.路径解析
    * PathAnalysis.cpp
    * 字符串处理，原来想复杂了，以为还要用树来维护路径信息，然而实际上直接进行字符串处理就好了，直接进行拼接，替换，删除等。
* _4.游戏_
* _5.网络连接_
***
## 2016 - 09
* 1.最大波动
    * MaxDiff.cpp
    * 简单题，遍历查找即可
* 2.火车购票
    * TicketsOrder_90_error.cpp 
    * 思路是用20*5的数组，然后加上行可用位置数，通过对每条命令操作数组，不知道最后怎么错了。
* 3.炉石传说
    * Hearthstone.cpp
    * 直接按照题目思路处理即可，注意英雄死亡游戏立刻结束
* _4.交通规划_
* _5.祭坛_
***
## 2016 - 12
* 1.中间数
    * Median.cpp
    * 排序，判断中间的是不是中间数，是输出，不是就没有。判断可以利用数组元素个数n个奇偶性。
* 2.工资计算
    * SalaryCalculate.cpp
    * 自己考试时使用动手方法算出来所有的逆推式子（蠢哭了。。）。然后这个在网上看到的思路，使用一个数组正向计算出来并把分段结果保存在表中，然后去查表。
* _3.权限查询_
* 4.压缩编码
    * ComEncode.cpp 
    * 石子合并问题，动规啊，没做过根本想不出来，这次要记住。
* _5.卡牌游戏_
***
## 2017 - 03
* 1.分蛋糕
    * HandOutCakes.cpp
    * 注意题目按序号从下到达，并不是重量，不要排序。
* 2.学生排队
    * StudentLineup.cpp
    * 直接根据命令一定数组元素就好，vector的erase()不太会用啊
* 3.Markdown
    * Markdown.cpp
    * 已经无心无力吐槽字符串，注意getline()之前先getchar()或者cin.get()读走换行符。find(),rfind不怎么会用，以后还是用循环吧。。。。string::npos是unsigned int型
* _4.地铁修建_
    * Subway.cpp
    * 用BFS和动规。只15分。。占坑先
* _5.引水入城_
***






















