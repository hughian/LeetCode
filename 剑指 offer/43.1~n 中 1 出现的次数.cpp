//
// Created by Hughian on 2020/4/4.
//


// 每次遇到这个题都有思路，但是每次都不能清晰地写出来。
// 依次计算每一位上 '1' 可能出现的次数
// 对于 个位            1,
//                (1-9)1, say [11, 21, 31, 41, 51, 61, 71, 81, 91]
//           (1-9)(0-9)1, say [101,...,191, 201, ......, 991]
//            .......
// 显然对于个位上可能出现1的次数为: 左边部分 + n % 10 != 0

// 对于 十位           1(0-9), say [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
//               (1-9)1(0-9), say [110,..., 119, 120, ......., 919]
//               .......
// 对于十位上可能出现 1的次数为:  如果十位数字大于1：
//                                 (左边部分 + 1) * 10
//                             如果十位数字等于1：
//                                 左边部分 * 10 + (右边部分 + 1) // 右边部分加1是因为可以取 [0,右边部分]闭区间
//                             如果十位数字等于0：
//                                 左边部分 * 10
// 将个位的情况重新组织成：      如果个位数字大于1：
//                                 (左边部分 + 1) * 1
//                             如果个位数字等于1：
//                                 左边部分 * 1 + (0 + 1)        // 个位时右边部分取0
//                             如果十位数字等于0：
//                                 左边部分 * 1
// 即可归纳如下算法。
class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int e = 1;
        int left, right, cur, ans = 0;
        while(n/e){
            left = n / (e * 10);
            cur = (n / e) % 10;
            right = n % e;

            if (cur == 0){
                ans += left * e;
            }else if(cur == 1){
                ans += left * e + right + 1;
            }else{
                ans += (left + 1) * e;
            }
            e *= 10;
        }
        return ans;
    }
};